const { fork } = require("child_process");
const crypto = require("crypto");

class WorkerPool {
  constructor({ workerPath, size = 2 }) {
    this.workerPath = workerPath;
    this.size = size;

    this.workers = [];
    this.idleWorkers = [];
    this.queue = [];
    this.callbacks = new Map();
    this.workerJobs = new Map(); // worker -> jobId

    this.init();
  }

  init() {
    for (let i = 0; i < this.size; i++) {
      this.createWorker();
    }
  }

  createWorker() {
    const worker = fork(this.workerPath);

    worker.on("message", (msg) => {
      const { jobId, success, result, error } = msg;

      const cb = this.callbacks.get(jobId);
      if (!cb) return;

      this.callbacks.delete(jobId);
      this.workerJobs.delete(worker);

      if (success) cb.resolve(result);
      else cb.reject(new Error(error));

      this.idleWorkers.push(worker);
      this.next();
    });

    worker.on("exit", () => {
      // Remove worker completely
      this.workers = this.workers.filter(w => w !== worker);
      this.idleWorkers = this.idleWorkers.filter(w => w !== worker);

      const jobId = this.workerJobs.get(worker);

      if (jobId) {
        const cb = this.callbacks.get(jobId);
        if (cb) {
          cb.reject(new Error("Worker crashed"));
          this.callbacks.delete(jobId);
        }
        this.workerJobs.delete(worker);
      }

      // ðŸ”¥ Respawn new worker
      this.createWorker();
    });

    this.workers.push(worker);
    this.idleWorkers.push(worker);
  }

  run(data, timeoutMs = 10 * 60 * 1000) {
    return new Promise((resolve, reject) => {
      const jobId = crypto.randomBytes(16).toString("hex");
      let finished = false;

      const safeResolve = (result) => {
        if (finished) return;
        finished = true;
        clearTimeout(timeout);
        resolve(result);
      };

      const safeReject = (err) => {
        if (finished) return;
        finished = true;
        clearTimeout(timeout);
        reject(err);
      };

      const timeout = setTimeout(() => {
        if (finished) return;
        finished = true;

        const worker = [...this.workerJobs.entries()]
          .find(([_, id]) => id === jobId)?.[0];

        if (worker) {
          worker.kill(); // ðŸ’£ Kill stuck worker
        }

        this.callbacks.delete(jobId);
        reject(new Error("Job timeout â€” worker killed"));
      }, timeoutMs);

      this.queue.push({
        jobId,
        data,
        resolve: safeResolve,
        reject: safeReject
      });

      this.next();
    });
  }

  next() {
    if (this.idleWorkers.length === 0) return;
    if (this.queue.length === 0) return;

    const worker = this.idleWorkers.shift();
    const job = this.queue.shift();

    this.callbacks.set(job.jobId, {
      resolve: job.resolve,
      reject: job.reject
    });

    this.workerJobs.set(worker, job.jobId);

    worker.send({
      jobId: job.jobId,
      payload: job.data
    });
  }
}

module.exports = WorkerPool;
